//
//  DBHelper.cpp
//
//  Created by Julian Koksal on 2022-09-25.
//

#include "DBHelper.hpp"

const DBHelper * DBHelper::instance = NULL;

DBHelper::~DBHelper()
{
    closeDB();
}

const DBHelper & DBHelper::getInstance()
{
    if (instance == NULL)
        instance = new DBHelper();
    return *instance;
}

long long DBHelper::insert(const Model &model) const
{
    // Generates the query.
    std::string query;
    query  = "INSERT INTO " + model.tableName() + " ";
    query += "VALUES (";
    for (int i = 0; i < model.columns().size(); i++)
    {
        query += "?,";
    }
    query  = query.substr(0, query.size() - 1);
    query += ");";
    
    sqlite3_stmt *statement = prepareStatement(query, "insert");
    
    // Iterates the columns of model and binds their values to the SQL statement.
    int index = 1; // SQL statement parameter index.
    bindStatementColumns(statement, model, model.columns(), index, "insert");
    
    sqlite3_step(statement);
    
    finalizeStatement(statement, "Error inserting to '" + model.tableName() + "'.");
    
    if (model.isAutoGeneratedKey())
    {
        return sqlite3_last_insert_rowid(db);
    }
    
    return 0;
}

void DBHelper::update(const Model &model) const
{
    std::set<std::string> keys = model.keys();
    // If the table has no primary keys then DBHelper::update cannot be used. Use DBHelper::updateWhere instead.
    if (keys.empty())
    {
        throw std::runtime_error("Error in call to DBHelper::update(). '" + model.tableName() + "' has no keys.");
    }
    
    // Names of all columns of the SQL table.
    std::vector<std::string> allColumns = model.columns();
    
    // Names of the columns to be updated.
    // Used to generate the SET command of the query. The corresponding values in the model will be bound to the SET command.
    std::vector<std::string> columnsToBind;
    
    // Names of primary key columns.
    // Used to generate the WHERE clause of the query. The corresponding values in the model will be bound to the WHERE clause.
    std::vector<std::string> keysToBind;
    
    for (std::vector<std::string>::iterator it = allColumns.begin(); it != allColumns.end(); it++)
    {
        // Keys should not be updated.
        if (keys.count(*it))
        {
            keysToBind.push_back(*it);
        }
        // All other columns will be updated.
        else
        {
            columnsToBind.push_back(*it);
        }
    }
    
    // Generates the query.
    std::string query;
    query  = "UPDATE " + model.tableName() + " SET ";
    for (std::vector<std::string>::iterator it = columnsToBind.begin(); it != columnsToBind.end(); it++)
    {
        query += *it + " = ?,";
    }
    query  = query.substr(0, query.size() - 1);
    query += generateWhereClauseFromKeys(keysToBind);
    query  = query.substr(0, query.size() - 5);
    query += ";";
    
    sqlite3_stmt *statement = prepareStatement(query, "update");
    
    // Iterates the columns, then keys, binding their corresponding values in model to the statement.
    int index = 1; // SQL statement parameter index.
    bindStatementColumns(statement, model, columnsToBind, index, "update");
    bindStatementColumns(statement, model, keysToBind, index, "update");
    
    sqlite3_step(statement);
    
    finalizeStatement(statement, "Error updating '" + model.tableName() + "'.");
}

void DBHelper::updateWhere(const Model &model, const std::vector<SqlCondition> &conditions, const std::set<std::string> &columns) const
{
    std::set<std::string> keys = model.keys();
    
    // Names of all columns of the SQL table.
    std::vector<std::string> allColumns = model.columns();
    
    // Names of the columns to be updated.
    // Used to generate the SET command of the query. The corresponding values in the model will be bound to the SET command.
    std::vector<std::string> columnsToBind;
    
    for (std::vector<std::string>::iterator it = allColumns.begin(); it != allColumns.end(); it++)
    {
        // Keys should not be updated.
        if (keys.count(*it))
        {
            continue;
        }
        // Only columns given in the columns parameter will be updated.
        // If the columns parameter is empty, then all columns will updated.
        if (columns.empty() || columns.count(*it))
        {
            columnsToBind.push_back(*it);;
        }
    }
    
    // Generates the query.
    std::string query;
    query  = "UPDATE " + model.tableName() + " SET ";
    for (std::vector<std::string>::iterator it = columnsToBind.begin(); it != columnsToBind.end(); it++)
    {
        query += *it + " = ?,";
    }
    query  = query.substr(0, query.size() - 1);
    if (!conditions.empty())
    {
        query += generateWhereClauseFromConditions(conditions);
    }
    query += ";";
    
    sqlite3_stmt *statement = prepareStatement(query, "Error preparing update statement.");
    
    // Iterates the columns of model and binds their values to the SET command of the SQL statement.
    // Then iterates the conditions and binds their values to the WHERE clause of the SQL statement.
    int index = 1; // SQL statement parameter index.
    bindStatementColumns(statement, model, columnsToBind, index, "updateWhere");
    bindStatementConditions(statement, conditions, index, "updateWhere");
    
    sqlite3_step(statement);
    
    finalizeStatement(statement, "Error updating '" + model.tableName() + "'.");
}

void DBHelper::destroy(const Model &model) const
{
    std::set<std::string> keys = model.keys();
    // If the table has no primary keys then DBHelper::destroy cannot be used. Use DBHelper::destroyWhere instead.
    if (keys.empty())
    {
        throw std::runtime_error("Error in call to DBHelper::destroy(). '" + model.tableName() + "' has no keys.");
    }
    
    // Names of all columns of the SQL table.
    std::vector<std::string> allColumns = model.columns();

    // Names of primary key columns.
    // Used to generate the WHERE clause of the query. The corresponding values in the model will be bound to the WHERE clause.
    std::vector<std::string> keysToBind;
    
    for (std::vector<std::string>::iterator it = allColumns.begin(); it != allColumns.end(); it++)
    {
        if (keys.count(*it))
        {
            keysToBind.push_back(*it);
        }
    }
    
    // Generates the query.
    std::string query;
    query  = "DELETE FROM " + model.tableName();
    query += generateWhereClauseFromKeys(keysToBind);
    query  = query.substr(0, query.size() - 5);
    query += ";";
    
    sqlite3_stmt *statement = prepareStatement(query, "destroy");
    
    // Iterates the keys of model and binds their values to the WHERE clause of the SQL statement.
    int index = 1; // SQL statement parameter index.
    bindStatementColumns(statement, model, keysToBind, index, "destroy");
    
    sqlite3_step(statement);
    
    finalizeStatement(statement, "Error deleting from '" + model.tableName() + "'.");
}

void DBHelper::destroyWhere(const Model &model, const std::vector<SqlCondition> &conditions) const
{
    // Generates the query.
    std::string query;
    query  = "DELETE FROM " + model.tableName();
    if (!conditions.empty())
    {
        query += generateWhereClauseFromConditions(conditions);
    }
    query += ";";
    
    sqlite3_stmt *statement = prepareStatement(query, "destroyWhere");
    
    // Iterates the conditions and binds their values to the WHERE clause of the SQL statement.
    int index = 1;
    bindStatementConditions(statement, conditions, index, "destroyWhere");
    
    sqlite3_step(statement);
    
    finalizeStatement(statement, "Error deleting from '" + model.tableName() + "'.");
}

DBHelper::DBHelper()
{
    openDB();
}

std::vector<Model *> DBHelper::selectWhereHelper(const Model &model, const std::vector<SqlCondition> &conditions, const std::string &orderBy,
                                                 const std::set<std::string> &columns) const
{
    // Names of all columns of the SQL table.
    std::vector<std::string> allColumns = model.columns();
    
    std::vector<std::string> columnsToSelect;
    for (std::vector<std::string>::iterator it = allColumns.begin(); it != allColumns.end(); it++)
    {
        // Only columns given in the columns parameter should be selected, unless the columns parameter is empty.
        if (columns.empty() || columns.count(*it))
        {
            columnsToSelect.push_back(*it);
        }
    }
    
    // Generates the query.
    std::string query;
    query  = "SELECT ";
    for (std::vector<std::string>::iterator it = columnsToSelect.begin(); it != columnsToSelect.end(); it++)
    {
        query += *it + ",";
    }
    query = query.substr(0, query.size() - 1);
    query += " FROM " + model.tableName();
    if (!conditions.empty())
    {
        query += generateWhereClauseFromConditions(conditions);
    }
    if (!orderBy.empty())
    {
        query += " ORDER BY " + orderBy;
    }
    query += ";";
    
    sqlite3_stmt *statement = prepareStatement(query, "Error preparing select statement.");
    
    // Iterates the conditions and binds their values to the WHERE clause of the SQL statement.
    int index = 1;
    bindStatementConditions(statement, conditions, index, "selectWhereHelper");
    
    // The result vector to be returned.
    std::vector<Model *> result;
    
    // Runs the select statement and creates a Model subclass object for each row of the results.
    int stepResult = sqlite3_step(statement);
    int columnCount = sqlite3_column_count(statement);
    while (stepResult == SQLITE_ROW)
    {
        // The map is used to determine column types and use the appropriate function to assign results back to the map.
        std::map<std::string, std::any> row = model.toMap();
        for (int i = 0; i < columnCount; i++)
        {
            const char *columnName = sqlite3_column_name(statement, i);
            const std::type_info *attrType = &row[columnName].type();
            if (*attrType == typeid(bool)) {
                row[columnName] = sqlite3_column_int(statement, i);
            }
            if (*attrType == typeid(int)) {
                row[columnName] = sqlite3_column_int(statement, i);
            }
            if (*attrType == typeid(double))
            {
                row[columnName] = sqlite3_column_double(statement, i);
            }
            if (*attrType == typeid(std::string))
            {
                row[columnName] = std::string((const char*)sqlite3_column_text(statement, i));
            }
        }
        // Creates a new object from the map.
        // Uses dynamic memory. Results are dereferenced then deleted in DBHelper::selectWhere().
        result.push_back(model.fromMap(row));
        
        stepResult = sqlite3_step(statement);
    }
    
    finalizeStatement(statement, "Error reading from database.");
    
    return result;
}

sqlite3_stmt * DBHelper::prepareStatement(const std::string &query, const std::string &queryType) const
{
    sqlite3_stmt *statement;
    int prepareResult = sqlite3_prepare_v2(db, query.c_str(), -1, &statement, NULL);
    if (prepareResult != SQLITE_OK)
    {
        sqlite3_finalize(statement);
        throw std::runtime_error("Error preparing " + queryType + " statement. SQLite3 error " + std::to_string(prepareResult) + ": "
                                 + std::string(sqlite3_errmsg(db)));
    }
    
    return statement;
}

std::string DBHelper::generateWhereClauseFromConditions(const std::vector<SqlCondition> &conditions) const
{
    std::string result = " WHERE ";
    for (std::vector<SqlCondition>::const_iterator it = conditions.begin(); it != conditions.end(); it++)
    {
        if (it->op == "IN")
        {
            result += it->field + " " + it->op + " (";
            for (int i = 0; i < std::any_cast<std::vector<std::string>>(it->value).size(); i++)
            {
                result += "?,";
            }
            result = result.substr(0, result.size() - 1) + ") AND ";
        }
        else
        {
            result += it->field + " " + it->op + " ? AND ";
        }
    }
    result  = result.substr(0, result.size() - 5);
    
    return result;
}

std::string DBHelper::generateWhereClauseFromKeys(const std::vector<std::string> &keys) const
{
    std::string result = " WHERE ";
    for (std::vector<std::string>::const_iterator it = keys.begin(); it != keys.end(); it++)
    {
        result += *it + " = ? AND ";
    }
    
    return result;
}

void DBHelper::bindStatementColumns(sqlite3_stmt *statement, const Model &model, const std::vector<std::string> &columns, int &index,
                                    const std::string &queryType) const
{
    std::map<std::string, std::any> mMap = model.toMap();
    
    for (std::vector<std::string>::const_iterator it = columns.begin(); it != columns.end(); it++)
    {
        int bindResult = -1;
        
        if (queryType == "insert" && model.isAutoGeneratedKey() && model.keys().count(*it))
        {
            // NULL is binded to the auto generated key column so that SQLite3 will automatically choose a unique value.
            bindResult = sqlite3_bind_null(statement, index);
        }
        else
        {
            const std::type_info *attrType = &mMap[*it].type();
            if (*attrType == typeid(bool))
            {
                bindResult = sqlite3_bind_int(statement, index, std::any_cast<bool>(mMap[*it]));
            }
            if (*attrType == typeid(int))
            {
                bindResult = sqlite3_bind_int(statement, index, std::any_cast<int>(mMap[*it]));
            }
            if (*attrType == typeid(double))
            {
                bindResult = sqlite3_bind_double(statement, index, std::any_cast<double>(mMap[*it]));
            }
            if (*attrType == typeid(std::string))
            {
                bindResult = sqlite3_bind_text(statement, index, std::any_cast<std::string>(mMap[*it]).c_str(), -1, SQLITE_TRANSIENT);
            }
        }
        
        if (bindResult != SQLITE_OK)
        {
            sqlite3_finalize(statement);
            if (bindResult == -1)
            {
                throw std::runtime_error("Error in call to DBHelper::" + queryType + "(). The value of '"
                                         + *it + "' is not a supported data type.");
            }
            throw std::runtime_error("Error binding " + queryType + " statement. SQLite3 error " + std::to_string(bindResult) + ": "
                                     + std::string(sqlite3_errmsg(db)));
        }
        
        index++;
    }
}

void DBHelper::bindStatementConditions(sqlite3_stmt *statement, const std::vector<SqlCondition> &conditions, int &index,
                                       const std::string &queryType) const
{
    for (std::vector<SqlCondition>::const_iterator it = conditions.begin(); it != conditions.end(); it++)
    {
        int bindResult = -1;
        
        const std::type_info *attrType = &it->value.type();
        if (*attrType == typeid(bool))
        {
            bindResult = sqlite3_bind_int(statement, index, std::any_cast<bool>(it->value));
        }
        if (*attrType == typeid(int))
        {
            bindResult = sqlite3_bind_int(statement, index, std::any_cast<int>(it->value));
        }
        if (*attrType == typeid(double))
        {
            bindResult = sqlite3_bind_double(statement, index, std::any_cast<double>(it->value));
        }
        if (*attrType == typeid(std::string))
        {
            bindResult = sqlite3_bind_text(statement, index, std::any_cast<std::string>(it->value).c_str(), -1, SQLITE_TRANSIENT);
        }
        if (*attrType == typeid(std::vector<std::string>))
        {
            std::vector<std::string> in = std::any_cast<std::vector<std::string>>(it->value);
            for (std::vector<std::string>::iterator itIn = in.begin(); itIn != in.end(); itIn++)
            {
                bindResult = sqlite3_bind_text(statement, index, std::any_cast<std::string>(*itIn).c_str(), -1, SQLITE_TRANSIENT);
                if (bindResult != SQLITE_OK)
                {
                    sqlite3_finalize(statement);
                    throw std::runtime_error("Error binding " + queryType + " statement. SQLite3 error " + std::to_string(bindResult) + ": "
                                             + std::string(sqlite3_errmsg(db)));
                }
                index++;
            }
            index--;
        }
        
        if (bindResult != SQLITE_OK)
        {
            sqlite3_finalize(statement);
            if (bindResult == -1)
            {
                throw std::runtime_error("Error in call to DBHelper::" + queryType + "(). The value of '"
                                         + it->field + "' is not a supported data type.");
            }
            throw std::runtime_error("Error binding " + queryType + " statement. SQLite3 error " + std::to_string(bindResult) + ": "
                                     + std::string(sqlite3_errmsg(db)));
        }
        
        index++;
    }
}

void DBHelper::finalizeStatement(sqlite3_stmt *statement, const std::string &errorMessage) const
{
    int finalizeResult = sqlite3_finalize(statement);
    if (finalizeResult != SQLITE_OK)
    {
        throw std::runtime_error(errorMessage + " SQLite3 error " + std::to_string(finalizeResult) + ": "
                                 + std::string(sqlite3_errmsg(db)));
    }
}

void DBHelper::openDB()
{
    const char* file_name = "sql/data.db";
    int result;
    result = sqlite3_open(file_name, &db);
    if (result != SQLITE_OK) {
        closeDB();
        throw std::runtime_error("Error opening database. SQLite3 error " + std::to_string(result) + ": "
                                 + std::string(sqlite3_errmsg(db)));
    }
}

void DBHelper::closeDB()
{
    int result;
    result = sqlite3_close(db);
    if (result != SQLITE_OK)
    {
        throw std::runtime_error("Error closing database. SQLite3 error " + std::to_string(result) + ": "
                                 + std::string(sqlite3_errmsg(db)));
    }
}
