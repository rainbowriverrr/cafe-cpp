//
//  DBHelper.cpp
//
//  Created by Julian Koksal on 2022-09-25.
//

#include "DBHelper.hpp"

const DBHelper * DBHelper::instance = NULL;

DBHelper::~DBHelper()
{
    closeDB();
}

const DBHelper & DBHelper::getInstance()
{
    if (instance == NULL)
        instance = new DBHelper();
    return *instance;
}

long long DBHelper::insert(const Model &model) const
{
    std::map<std::string, std::any> mMap = model.toMap();
    
    std::string query;
    query  = "INSERT INTO " + model.tableName() + " ";
    query += "VALUES (?";
    for (int i = 1; i < mMap.size(); i++)
    {
        query += ",?";
    }
    query += ");";
    
    sqlite3_stmt *statement;
    int prepareResult = sqlite3_prepare_v2(db, query.c_str(), -1, &statement, NULL);
    if (prepareResult != SQLITE_OK)
    {
        sqlite3_finalize(statement);
        throw std::runtime_error("Error preparing insert statement. SQLite3 error " + std::to_string(prepareResult) + ": "
                                 + std::string(sqlite3_errmsg(db)));
    }
    
    // Iterates the columns of model and binds their values to the SQL statement.
    int index = 1; // SQL statement parameter index.
    std::vector<std::string> columns = model.columns();
    for (std::vector<std::string>::const_iterator it = columns.begin(); it != columns.end(); it++)
    {
        int bindResult = -1;
        
        if (model.keys().count(*it) && model.isAutoGeneratedKey())
        {
            // NULL is binded to the auto generated key column so that SQLite3 will automatically choose a unique value.
            bindResult = sqlite3_bind_null(statement, index);
        }
        else
        {
            const std::type_info *attrType = &mMap[*it].type();
            if (*attrType == typeid(bool))
            {
                bindResult = sqlite3_bind_int(statement, index, std::any_cast<bool>(mMap[*it]));
            }
            if (*attrType == typeid(int))
            {
                bindResult = sqlite3_bind_int(statement, index, std::any_cast<int>(mMap[*it]));
            }
            if (*attrType == typeid(double))
            {
                bindResult = sqlite3_bind_double(statement, index, std::any_cast<double>(mMap[*it]));
            }
            if (*attrType == typeid(std::string))
            {
                bindResult = sqlite3_bind_text(statement, index, std::any_cast<std::string>(mMap[*it]).c_str(), -1, SQLITE_TRANSIENT);
            }
        }
        
        if (bindResult != SQLITE_OK)
        {
            sqlite3_finalize(statement);
            if (bindResult == -1)
            {
                throw std::runtime_error("Error in call to DBHelper::insert(). The value of '"
                                         + *it + "' is not a supported data type.");
            }
            throw std::runtime_error("Error binding insert statement. SQLite3 error " + std::to_string(bindResult) + ": "
                                     + std::string(sqlite3_errmsg(db)));
        }
        
        index++;
    }
    
    sqlite3_step(statement);
    
    int finalizeResult = sqlite3_finalize(statement);
    if (finalizeResult != SQLITE_OK)
    {
        throw std::runtime_error("Error inserting to '" + model.tableName() + "'. SQLite3 error " + std::to_string(finalizeResult) + ": "
                                 + std::string(sqlite3_errmsg(db)));
    }
    
    if (model.isAutoGeneratedKey())
    {
        return sqlite3_last_insert_rowid(db);
    }
    
    return 0;
}

void DBHelper::update(const Model &model) const
{
    std::set<std::string> keys = model.keys();
    // If the table has no primary keys then DBHelper::update cannot be used. Use DBHelper::updateWhere instead.
    if (keys.empty())
    {
        throw std::runtime_error("Error in call to DBHelper::update(). '" + model.tableName() + "' has no keys.");
    }
    
    std::map<std::string, std::any> mMap = model.toMap();
    
    std::string query;
    query  = "UPDATE " + model.tableName() + " SET ";
    // Iterates field names of model to generate the SET command.
    std::vector<std::string> columns = model.columns();
    for (std::vector<std::string>::const_iterator it = columns.begin(); it != columns.end(); it++)
    {
        // Primary keys should not be updated.
        if (!keys.count(*it))
        {
            query += *it + " = ?,";
        }
    }
    query  = query.substr(0, query.size() - 1);
    query += " WHERE 1=1";
    // Iterates key fields of model to generate the WHERE clause.
    for (std::set<std::string>::iterator it = keys.begin(); it != keys.end(); it++)
    {
        query += " AND " + *it + " = ?";
    }
    query += ";";
    
    sqlite3_stmt *statement;
    int prepareResult = sqlite3_prepare_v2(db, query.c_str(), -1, &statement, NULL);
    if (prepareResult != SQLITE_OK)
    {
        sqlite3_finalize(statement);
        throw std::runtime_error("Error preparing update statement. SQLite3 error " + std::to_string(prepareResult) + ": "
                                 + std::string(sqlite3_errmsg(db)));
    }
    
    // Iterates the columns of model and binds their values to the SET command part of the SQL statement.
    int index = 1; // SQL statement parameter index.
    for (std::vector<std::string>::const_iterator it = columns.begin(); it != columns.end(); it++)
    {
        if (keys.count(*it))
        {
            continue;
        }
        
        int bindResult = -1;
        
        const std::type_info *attrType = &mMap[*it].type();
        if (*attrType == typeid(bool))
        {
            bindResult = sqlite3_bind_int(statement, index, std::any_cast<bool>(mMap[*it]));
        }
        if (*attrType == typeid(int))
        {
            bindResult = sqlite3_bind_int(statement, index, std::any_cast<int>(mMap[*it]));
        }
        if (*attrType == typeid(double))
        {
            bindResult = sqlite3_bind_double(statement, index, std::any_cast<double>(mMap[*it]));
        }
        if (*attrType == typeid(std::string))
        {
            bindResult = sqlite3_bind_text(statement, index, std::any_cast<std::string>(mMap[*it]).c_str(), -1, SQLITE_TRANSIENT);
        }
        
        if (bindResult != SQLITE_OK)
        {
            sqlite3_finalize(statement);
            if (bindResult == -1)
            {
                throw std::runtime_error("Error in call to DBHelper::update(). The value of '"
                                         + *it + "' is not a supported data type.");
            }
            throw std::runtime_error("Error binding update statement. SQLite3 error " + std::to_string(bindResult) + ": "
                                     + std::string(sqlite3_errmsg(db)));
        }
        
        index++;
    }
    
    // Iterates the key fields of model and binds their values to the WHERE clause of the SQL statement.
    for (std::set<std::string>::iterator it = keys.begin(); it != keys.end(); it++)
    {
        int bindResult = -1;
        
        const std::type_info *attrType = &mMap[*it].type();
        if (*attrType == typeid(int))
        {
            bindResult = sqlite3_bind_int(statement, index, std::any_cast<int>(mMap[*it]));
        }
        if (*attrType == typeid(std::string))
        {
            bindResult = sqlite3_bind_text(statement, index, std::any_cast<std::string>(mMap[*it]).c_str(), -1, SQLITE_TRANSIENT);
        }
        
        if (bindResult != SQLITE_OK)
        {
            sqlite3_finalize(statement);
            if (bindResult == -1)
            {
                throw std::runtime_error("Error in call to DBHelper::update(). The value of '"
                                         + *it + "' is not a supported data type.");
            }
            throw std::runtime_error("Error binding update statement. SQLite3 error " + std::to_string(bindResult) + ": "
                                     + std::string(sqlite3_errmsg(db)));
        }
        
        index++;
    }
    
    sqlite3_step(statement);
    
    int finalizeResult = sqlite3_finalize(statement);
    if (finalizeResult != SQLITE_OK)
    {
        throw std::runtime_error("Error updating '" + model.tableName() + "'. SQLite3 error " + std::to_string(finalizeResult) + ": "
                                 + std::string(sqlite3_errmsg(db)));
    }
}

void DBHelper::updateWhere(const Model &model, std::vector<SqlCondition> conditions, std::set<std::string> columns) const
{
    std::map<std::string, std::any> mMap = model.toMap();
    std::set<std::string> keys = model.keys();
    
    for (std::set<std::string>::iterator it = columns.begin(); it != columns.end(); it++)
    {
        if (!mMap.count(*it))
        {
            throw std::runtime_error("Error in call to DBHelper::updateWhere(). '" + *it + "' is not a column of '"
                                     + model.tableName() + "'.");
        }
        if (keys.count(*it))
        {
            throw std::runtime_error("Error in call to DBHelper::updateWhere(). '" + *it + "' is a primary key of '"
                                     + model.tableName() + "'. Primary keys cannot be updated.");
        }
    }
    
    std::string query;
    query  = "UPDATE " + model.tableName() + " SET ";
    // Iterates the columns of model to generate the SET command.
    std::vector<std::string> allColumns = model.columns();
    for (std::vector<std::string>::const_iterator it = allColumns.begin(); it != allColumns.end(); it++)
    {
        // Primary keys should not be updated.
        if (keys.count(*it))
        {
            continue;
        }
        if (!columns.empty() && !columns.count(*it))
        {
            continue;
        }
        
        query += *it + " = ?,";
    }
    query  = query.substr(0, query.size() - 1);
    query += " WHERE 1=1";
    // Iterates the conditions parameter to generate the WHERE clause.
    for (int i = 0; i < conditions.size(); i++)
    {
        query += " AND " + conditions[i].field + " " + conditions[i].op + " ?";
    }
    query += ";";
    
    sqlite3_stmt *statement;
    int prepareResult = sqlite3_prepare_v2(db, query.c_str(), -1, &statement, NULL);
    if (prepareResult != SQLITE_OK)
    {
        sqlite3_finalize(statement);
        throw std::runtime_error("Error preparing update statement. SQLite3 error " + std::to_string(prepareResult) + ": "
                                 + std::string(sqlite3_errmsg(db)));
    }
    
    // Iterates the columns of model and binds their values to the SET command part of the SQL statement.
    int index = 1; // SQL statement parameter index.
    for (std::vector<std::string>::const_iterator it = allColumns.begin(); it != allColumns.end(); it++)
    {
        if (keys.count(*it))
        {
            continue;
        }
        if (!columns.empty() && !columns.count(*it))
        {
            continue;
        }
        
        int bindResult = -1;
        
        const std::type_info *attrType = &mMap[*it].type();
        if (*attrType == typeid(bool))
        {
            bindResult = sqlite3_bind_int(statement, index, std::any_cast<bool>(mMap[*it]));
        }
        if (*attrType == typeid(int))
        {
            bindResult = sqlite3_bind_int(statement, index, std::any_cast<int>(mMap[*it]));
        }
        if (*attrType == typeid(double))
        {
            bindResult = sqlite3_bind_double(statement, index, std::any_cast<double>(mMap[*it]));
        }
        if (*attrType == typeid(std::string))
        {
            bindResult = sqlite3_bind_text(statement, index, std::any_cast<std::string>(mMap[*it]).c_str(), -1, SQLITE_TRANSIENT);
        }
        
        if (bindResult != SQLITE_OK)
        {
            sqlite3_finalize(statement);
            if (bindResult == -1)
            {
                throw std::runtime_error("Error in call to DBHelper::updateWhere(). The value of '"
                                         + *it + "' is not a supported data type.");
            }
            throw std::runtime_error("Error binding update statement. SQLite3 error " + std::to_string(bindResult) + ": "
                                     + std::string(sqlite3_errmsg(db)));
        }
        
        index++;
    }
    
    // Iterates the conditions parameter and binds their values to the WHERE clause of the SQL statement.
    for (std::vector<SqlCondition>::iterator it = conditions.begin(); it != conditions.end(); it++)
    {
        int bindResult = -1;
        
        const std::type_info *attrType = &it->value.type();
        if (*attrType == typeid(bool))
        {
            bindResult = sqlite3_bind_int(statement, index, std::any_cast<bool>(it->value));
        }
        if (*attrType == typeid(int))
        {
            bindResult = sqlite3_bind_int(statement, index, std::any_cast<int>(it->value));
        }
        if (*attrType == typeid(double))
        {
            bindResult = sqlite3_bind_double(statement, index, std::any_cast<double>(it->value));
        }
        if (*attrType == typeid(std::string))
        {
            bindResult = sqlite3_bind_text(statement, index, std::any_cast<std::string>(it->value).c_str(), -1, SQLITE_TRANSIENT);
        }
        
        if (bindResult != SQLITE_OK)
        {
            sqlite3_finalize(statement);
            if (bindResult == -1)
            {
                throw std::runtime_error("Error in call to DBHelper::updateWhere(). The value of '"
                                         + it->field + "' is not a supported data type.");
            }
            throw std::runtime_error("Error binding update statement. SQLite3 error " + std::to_string(bindResult) + ": "
                                     + std::string(sqlite3_errmsg(db)));
        }
        
        index++;
    }
    
    sqlite3_step(statement);
    
    int finalizeResult = sqlite3_finalize(statement);
    if (finalizeResult != SQLITE_OK)
    {
        throw std::runtime_error("Error updating '" + model.tableName() + "'. SQLite3 error " + std::to_string(finalizeResult) + ": "
                                 + std::string(sqlite3_errmsg(db)));
    }
}

void DBHelper::destroy(const Model &model) const
{
    std::set<std::string> keys = model.keys();
    // If the table has no primary keys then DBHelper::destroy cannot be used. Use DBHelper::destroyWhere instead.
    if (keys.empty())
    {
        throw std::runtime_error("Error in call to DBHelper::destroy(). '" + model.tableName() + "' has no keys.");
    }
    
    std::map<std::string, std::any> mMap = model.toMap();
    
    std::string query;
    query  = "DELETE FROM " + model.tableName() + " WHERE 1=1";
    // Iterates the key fields of model to generate the WHERE clause.
    for (std::set<std::string>::iterator it = keys.begin(); it != keys.end(); it++)
    {
        query += " AND " + *it + " = ?";
    }
    query += ";";
    
    sqlite3_stmt *statement;
    int prepareResult = sqlite3_prepare_v2(db, query.c_str(), -1, &statement, NULL);
    if (prepareResult != SQLITE_OK)
    {
        sqlite3_finalize(statement);
        throw std::runtime_error("Error preparing delete statement. SQLite3 error " + std::to_string(prepareResult) + ": "
                                 + std::string(sqlite3_errmsg(db)));
    }
    
    // Iterates the key fields of model and binds their values to the WHERE clause of the SQL statement.
    int index = 1; // SQL statement parameter index.
    for (std::set<std::string>::iterator it = keys.begin(); it != keys.end(); it++)
    {
        int bindResult = -1;
        
        const std::type_info *attrType = &mMap[*it].type();
        if (*attrType == typeid(int))
        {
            bindResult = sqlite3_bind_int(statement, index, std::any_cast<int>(mMap[*it]));
        }
        if (*attrType == typeid(std::string))
        {
            bindResult = sqlite3_bind_text(statement, index, std::any_cast<std::string>(mMap[*it]).c_str(), -1, SQLITE_TRANSIENT);
        }
        
        if (bindResult != SQLITE_OK)
        {
            sqlite3_finalize(statement);
            if (bindResult == -1)
            {
                throw std::runtime_error("Error in call to DBHelper::destroy(). The value of '"
                                         + *it + "' is not a supported data type.");
            }
            throw std::runtime_error("Error binding update statement. SQLite3 error " + std::to_string(bindResult) + ": "
                                     + std::string(sqlite3_errmsg(db)));
        }
        
        index++;
    }
    
    sqlite3_step(statement);
    
    int finalizeResult = sqlite3_finalize(statement);
    if (finalizeResult != SQLITE_OK)
    {
        throw std::runtime_error("Error deleting from '" + model.tableName() + "'. SQLite3 error " + std::to_string(finalizeResult) + ": "
                                 + std::string(sqlite3_errmsg(db)));
    }
}

void DBHelper::destroyWhere(const Model &model, std::vector<SqlCondition> conditions) const
{
    std::string query;
    query  = "DELETE FROM " + model.tableName() + " WHERE 1=1";
    // Iterates the conditions parameter to generate the WHERE clause.
    for (int i = 0; i < conditions.size(); i++)
    {
        query += " AND " + conditions[i].field + " " + conditions[i].op + " ?";
    }
    query += ";";
    
    sqlite3_stmt *statement;
    int prepareResult = sqlite3_prepare_v2(db, query.c_str(), -1, &statement, NULL);
    if (prepareResult != SQLITE_OK)
    {
        sqlite3_finalize(statement);
        throw std::runtime_error("Error preparing delete statement. SQLite3 error " + std::to_string(prepareResult) + ": "
                                 + std::string(sqlite3_errmsg(db)));
    }
    
    // Iterates the conditions parameter and binds their values to the WHERE clause of the SQL statement.
    int index = 1;
    for (std::vector<SqlCondition>::iterator it = conditions.begin(); it != conditions.end(); it++)
    {
        int bindResult = -1;
        
        const std::type_info *attrType = &it->value.type();
        if (*attrType == typeid(bool))
        {
            bindResult = sqlite3_bind_int(statement, index, std::any_cast<bool>(it->value));
        }
        if (*attrType == typeid(int))
        {
            bindResult = sqlite3_bind_int(statement, index, std::any_cast<int>(it->value));
        }
        if (*attrType == typeid(double))
        {
            bindResult = sqlite3_bind_double(statement, index, std::any_cast<double>(it->value));
        }
        if (*attrType == typeid(std::string))
        {
            bindResult = sqlite3_bind_text(statement, index, std::any_cast<std::string>(it->value).c_str(), -1, SQLITE_TRANSIENT);
        }
        
        if (bindResult != SQLITE_OK)
        {
            sqlite3_finalize(statement);
            if (bindResult == -1)
            {
                throw std::runtime_error("Error in call to DBHelper::destroyWhere(). The value of '"
                                         + it->field + "' is not a supported data type.");
            }
            throw std::runtime_error("Error binding update statement. SQLite3 error " + std::to_string(bindResult) + ": "
                                     + std::string(sqlite3_errmsg(db)));
        }
        
        index++;
    }
    
    sqlite3_step(statement);
    
    int finalizeResult = sqlite3_finalize(statement);
    if (finalizeResult != SQLITE_OK)
    {
        throw std::runtime_error("Error deleting from '" + model.tableName() + "'. SQLite3 error " + std::to_string(finalizeResult) + ": "
                                 + std::string(sqlite3_errmsg(db)));
    }
}

DBHelper::DBHelper()
{
    openDB();
}

std::vector<Model *> DBHelper::selectWhereHelper(const Model &model, std::vector<SqlCondition> conditions, std::string orderBy,
                                                 std::set<std::string> columns) const
{
    std::map<std::string, std::any> mMap = model.toMap();
    
    std::string query;
    query  = "SELECT ";
    // Iterates the columns of model to generate the projection part of the select statement.
    // If a non-empty columns parameter is given then only the field names that are also in columns will be included.
    std::vector<std::string> allColumns = model.columns();
    for (std::vector<std::string>::const_iterator it = allColumns.begin(); it != allColumns.end(); it++)
    {
        if (columns.empty() || columns.count(*it))
        {
            query += *it + ",";
        }
    }
    query = query.substr(0, query.size() - 1);
    query += " FROM " + model.tableName();
    query += " WHERE 1=1";
    // Iterates the conditions parameter to generate the WHERE clause.
    for (std::vector<SqlCondition>::iterator it = conditions.begin(); it != conditions.end(); it++)
    {
        query += " AND " + it->field + " " + it->op + " ?";
    }
    if (!orderBy.empty())
    {
        query += " ORDER BY " + orderBy;
    }
    query += ";";
    
    sqlite3_stmt *statement;
    int prepareResult = sqlite3_prepare_v2(db, query.c_str(), -1, &statement, nullptr);
    if (prepareResult != SQLITE_OK)
    {
        throw std::runtime_error("Error preparing select statement. SQLite3 error " + std::to_string(prepareResult) + ": "
                                 + std::string(sqlite3_errmsg(db)));
    }
    
    // Iterates the conditions parameter and binds their values to the WHERE clause of the SQL statement.
    int index = 1;
    for (std::vector<SqlCondition>::iterator it = conditions.begin(); it != conditions.end(); it++)
    {
        int bindResult = -1;
        
        const std::type_info *attrType = &it->value.type();
        if (*attrType == typeid(bool))
        {
            bindResult = sqlite3_bind_int(statement, index, std::any_cast<bool>(it->value));
        }
        if (*attrType == typeid(int))
        {
            bindResult = sqlite3_bind_int(statement, index, std::any_cast<int>(it->value));
        }
        if (*attrType == typeid(double))
        {
            bindResult = sqlite3_bind_double(statement, index, std::any_cast<double>(it->value));
        }
        if (*attrType == typeid(std::string))
        {
            bindResult = sqlite3_bind_text(statement, index, std::any_cast<std::string>(it->value).c_str(), -1, SQLITE_TRANSIENT);
        }
        
        if (bindResult != SQLITE_OK)
        {
            sqlite3_finalize(statement);
            if (bindResult == -1)
            {
                throw std::runtime_error("Error in call to DBHelper::selectWhere(). The value of the SqlCondition with field '"
                                         + it->field + "' is not a supported data type.");
            }
            throw std::runtime_error("Error binding select statement. SQLite3 error " + std::to_string(bindResult) + ": "
                                     + std::string(sqlite3_errmsg(db)));
        }
        
        index++;
    }
    
    std::vector<Model *> result;
    int stepResult = sqlite3_step(statement);
    int columnCount = sqlite3_column_count(statement);
    while (stepResult == SQLITE_ROW)
    {
        // The map is used to determine column types and use the appropriate function to assign results back to the map.
        std::map<std::string, std::any> row = model.toMap();
        for (int i = 0; i < columnCount; i++)
        {
            const char *columnName = sqlite3_column_name(statement, i);
            const std::type_info *attrType = &row[columnName].type();
            if (*attrType == typeid(bool)) {
                row[columnName] = sqlite3_column_int(statement, i);
            }
            if (*attrType == typeid(int)) {
                row[columnName] = sqlite3_column_int(statement, i);
            }
            if (*attrType == typeid(double))
            {
                row[columnName] = sqlite3_column_double(statement, i);
            }
            if (*attrType == typeid(std::string))
            {
                row[columnName] = std::string((const char*)sqlite3_column_text(statement, i));
            }
        }
        // Creates a new object from the map.
        // Uses dynamic memory! Results must be deleted later.
        result.push_back(model.fromMap(row));
        stepResult = sqlite3_step(statement);
    }
    
    int finalizeResult = sqlite3_finalize(statement);
    if (finalizeResult != SQLITE_OK)
    {
        throw std::runtime_error("Error reading from database. SQLite3 error " + std::to_string(finalizeResult) + ": "
                                 + std::string(sqlite3_errmsg(db)));
    }
    
    return result;
}

void DBHelper::openDB()
{
    const char* file_name = "resources/data.db";
    int result;
    result = sqlite3_open(file_name, &db);
    if (result != SQLITE_OK) {
        closeDB();
        throw std::runtime_error("Error opening database. SQLite3 error " + std::to_string(result) + ": "
                                 + std::string(sqlite3_errmsg(db)));
    }
}

void DBHelper::closeDB()
{
    int result;
    result = sqlite3_close(db);
    if (result != SQLITE_OK)
    {
        throw std::runtime_error("Error closing database. SQLite3 error " + std::to_string(result) + ": "
                                 + std::string(sqlite3_errmsg(db)));
    }
}
